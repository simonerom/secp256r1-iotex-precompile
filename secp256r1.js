// This script mocks an IoT device or a smartphone that 
// features a secure enclave which can sign messages using 
// the P-256 (secp256r1) elliptic curve.

// Load the private key from .env
require('dotenv').config();

const { Web3 } = require('web3');
const EC = require('elliptic').ec;

const web3 = new Web3('https://babel-api.testnet.iotex.io');

// Set up the elliptic curve for secp256r1 (also known as P256)
const ec = new EC('p256'); 

// Use the private key of the blockchain account to sign the IoTeX transaction
const account = web3.eth.accounts.privateKeyToAccount(process.env.IOTEX_PRIVATE_KEY);
web3.eth.accounts.wallet.add(account);
web3.eth.defaultAccount = account.address;

// Contract address of the deployed contract
const contractAddress = process.env.SECP256K1_CONTRACT_ADDRESS;

// ABI of the contract
const contractABI = [
	{
		"inputs": [
			{ "internalType": "string", "name": "timestamp", "type": "string" },
			{ "internalType": "string", "name": "latitude", "type": "string" },
			{ "internalType": "string", "name": "longitude", "type": "string" },
			{ "internalType": "string", "name": "temperature", "type": "string" },
			{ "internalType": "bytes32", "name": "r", "type": "bytes32" },
			{ "internalType": "bytes32", "name": "s", "type": "bytes32" },
			{ "internalType": "bytes", "name": "pubKey", "type": "bytes" }
		],
		"name": "verifyIoTData",
		"outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
		"stateMutability": "view",
		"type": "function"
	}
];

// Create contract instance
const contract = new web3.eth.Contract(contractABI, contractAddress);

// Example IoT data, this could be generated by a sensor or a smartphone
const message = {
  timestamp: "1234567890",
  latitude: "45.123",
  longitude: "-93.456",
  temperature: "25.1"
};

console.log(JSON.stringify(message));

// Hash the message using abi.encodePacked equivalent in JS
const messageHash = web3.utils.keccak256(web3.utils.encodePacked(
  web3.utils.asciiToHex(message.timestamp),
  web3.utils.asciiToHex(message.latitude),
  web3.utils.asciiToHex(message.longitude),
  web3.utils.asciiToHex(message.temperature)
));
console.log("Hashed message:", messageHash);

// Convert the message hash to a buffer of raw bytes before signing
const messageHashBytes = Buffer.from(messageHash.slice(2), 'hex');

// Generate a new keypair using secp256r1
const keyPair = ec.genKeyPair();  // Or use an existing private key here

// Sign the message hash with the elliptic keypair (sign expects bytes)
const signature = keyPair.sign(messageHashBytes);

// Extract r and s from the signature
const r = '0x' + signature.r.toString(16).padStart(64, '0');
const s = '0x' + signature.s.toString(16).padStart(64, '0');

// Get the public key in uncompressed form (x and y coordinates)
let pubKey = keyPair.getPublic(false, 'hex'); // false for uncompressed

// Log the data for debugging
console.log("Timestamp:", message.timestamp);
console.log("Latitude:", message.latitude);
console.log("Longitude:", message.longitude);
console.log("Temperature:", message.temperature);
console.log("r:", r);
console.log("s:", s);
console.log("Public Key:", pubKey);

// Call the contract to verify the signature
async function verifySignature() {
  try {
    const isValid = await contract.methods.verifyIoTData(
      message.timestamp,
      message.latitude,
      message.longitude,
      message.temperature,
      r,
      s,
      web3.utils.hexToBytes(pubKey)  // Convert the public key to bytes
    ).call();

    console.log('Is signature valid?', isValid);
  } catch (error) {
    console.error('Error verifying signature:', error);
  }
}

// 
verifySignature();
